%-----------------------------------------------------------------------
% Template File for Science China Information Sciences
% Downloaded from http://scis.scichina.com
% Please compile the tex file using LATEX or PDF-LATEX or CCT-LATEX
%-----------------------------------------------------------------------
\documentclass{SCIS2021}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Author's definitions for this manuscript
%%% 作者附加的定义
%%% 常用环境已经加载好, 不需要重复加载
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
%\usepackage{multirow}
\usepackage{graphicx,float}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{color,xcolor}
\usepackage{microtype} 
%\usepackage{framed}
%\usepackage{lineno}
%\usepackage{subfigure}

\usepackage{tikz}

\usepackage{pgfplots}

\usetikzlibrary{shapes.geometric, arrows}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Begin. 开始
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%\oa
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Authors do not modify the information below
%%% 作者不需要修改此处信息
\ArticleType{RESEARCH PAPER}
%\SpecialTopic{}
%\luntan
\Year{2020}
\Month{}
\Vol{}
\No{}
\DOI{}
\ArtNo{}
\ReceiveDate{}
\ReviseDate{}
\AcceptDate{}
\OnlineDate{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% title: 标题
%%%   \title{title}{title for citation}
\title{Simple Yet Fast Two-Party Signature Based on ECDSA}{Simple Yet Fast Two-Party Signature Based on ECDSA}

%%% Corresponding author: 通信作者
%%%   \author[number]{Full name}{{email@xxx.com}}
%%% General author: 一般作者
%%%   \author[number]{Full name}{}
\author[1,2]{Binbin Tu}{}
\author[1]{Yu Chen}{{cycosmic@gmail.com}}
\author[3]{Hongrui Cui}{}
\author[2]{Xianfang Wang}{}

%%% Author information for page head. 页眉中的作者信息
\AuthorMark{Binbin Tu}

%%% Authors for citation. 首页引用中的作者信息
\AuthorCitation{Binbin Tu, Yu Chen, Hongrui Cui, et al}

%%% Authors' contribution. 同等贡献
%\contributions{Authors A and B have the same contribution to this work.}

%%% Address. 地址
%%%   \address[number]{Affiliation, City {\rm Postcode}, Country}
\address[1]{School of Cyber Science and Technology, Shandong University, Qindao, China}
\address[2]{Westone Cryptologic Research Center, Westone Information Industry Inc, Beijing, China}
\address[3]{Department of Computer Science and Engineering, Shanghai Jiao Tong University, Shanghai, China}

%%% Abstract. 摘要
\abstract{ECDSA is a standardized signature scheme and is widely used in many fields. However, most two-party ECDSA needs a complicated multi-party computation technique to compute the multiplication of many shared secrets and requires expensive zero-knowledge proofs to deal with malicious adversaries.

In this paper, we propose a simple and fast two-party signing protocol based on ECDSA security, whose signing operation of each party is similar to the original ECDSA signing algorithm. Therefore, it can enjoy the same efficiency as ECDSA and reuses the implementation of ECDSA greatly, and upgrades the existing ECDSA application to two-party scenario friendly. For this purpose, we first introduce a variant of ECDSA called combinatorial ECDSA, which is as secure as the standard ECDSA and can be split into two pieces easily. Then, benefiting from the structure of combinatorial ECDSA, we devise a fast two-party signing protocol without complicated multi-party computation and give the security proof based on ECDSA. Compared with the state-of-the-art two-party ECDSA, the signing result of each party in our protocol preserves the structure of the ECDSA signature, which can be verified easily and avoids expensive zero-knowledge proofs. Last, we conduct an experimental evaluation, demonstrating that the performance of our combinatorial ECDSA and two-party signature is similar to ECDSA and the experimental results show that our proposed schemes are practical.}

%%% Keywords. 关键词
\keywords{Two-party signature, ECDSA, Combinatorial ECDSA, Signing key protection}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The main text. 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:introduction}

The two-party signature~\cite{MR01,GGN16,Lin17,BGG17,DKLs18,LN18,GG18,DKLs19,CCLST19,ZHZC20} can split the signing key into two parts and each belongs to one signing party so that a valid signature can be generated by both parties together via a secure protocol. This kind of signature is beneficial to the protection of the signing key because the adversary needs to corrupt both parties to obtain the signing key. 

With the benefits of key length and efficiency, ECDSA~\cite{ECDSA} is widely used in many fields such as TLS~\cite{rfc4492}, DNSSec~\cite{rfc6605}, and many cryptocurrencies, including Bitcoin~\cite{Nak08} and Ethereum. As we all know, the security protection of the signing key is the core of signature security. Especially in cryptocurrencies, a signing key loss means concrete financial losses. Therefore, a two-party signature based on ECDSA can provide a high level of signing key protection, which also means better security for your wallet.  

However, how to design a two-party signing protocol based on ECDSA is more complicated than many other types of signatures~\cite{RSA78,Sch89}, because (i) a shared secret must be inverted, and (ii) a multiplication must be performed on two shared secrets~\cite{MR01}. In order to solve these problems, many heavy multi-party computation (MPC) techniques are applied, such as homomorphic encryption~\cite{MR01,GGN16,Lin17}, and oblivious transfer~\cite{DKLs18,DKLs19}, etc. More precisely, both parties hold part of the shared signing key and a random value, then take in those as privacy input and split the signing algorithm by using MPC protocol to compute a signature. However, computing multiplication between two-party is always complicated. Especially, the protocol also requires additional expensive zero-knowledge proofs to ensure that each party works correctly.  MacKenzie and Reiter~\cite{MR01} first present a provably secure two-party DSA signature by using homomorphic encryption~\cite{HMRT12}. Gennaro et al.~\cite{GGN16} take advantage of threshold homomorphic encryption, and give the first threshold-optimal ECDSA signature scheme. After that, Lindell~\cite{Lin17} points out that~\cite{MR01} and~\cite{GGN16} need complicated zero-knowledge proof in the signing phase. So he proposes a new two-party ECDSA and improves the efficiency of the signing operation by modifying the key generation algorithm in which one party encrypts the secret key once and another can use it to sign all the time. However, the protocol is hard to get rid of using homomorphic encryption, causing that key generation operation is heavy. Subsequently, Castagnos et al.~\cite{CCLST19} generalize Lindell's solution~\cite{Lin17} and provide a generic construction for two-party ECDSA from hash proof systems (HPS). But their protocol still requires that the underlying HPS needs homomorphic properties and is also difficult to avoid the heavy key generation operation. Different from before, Doerner et al.~\cite{DKLs18,DKLs19} point out that using homomorphic encryption leads both to poor performance and to reliance upon little-studied assumptions, and propose a two-party ECDSA based on the ECDSA assumption itself. But their scheme requires additional oblivious transfer to turn the multiplication on private inputs into the addition.

To the best of our knowledge, existing two-party signing protocols based on ECDSA changes the structure of original ECDSA signing algorithm a lot by using heavy MPC technique such as homomorphic encryption, oblivious transfer, etc. Therefore, extending the two-party scenario for existing ECDSA applications, the above schemes need to abandon the existing hardware and software implementation of the ECDSA signing algorithm and re-implement the two-party signing protocol. On the one hand, this method wastes the original signing implementation resources of existing ECDSA applications, on the other hand, the complex two-party signing structure increases the difficulty of implementation and application. Furthermore, in cryptosystems, security depends on its weakest component. Therefore, using more additional tools greatly affects security as well as efficiency. In particular, most two-party signing protocols based on ECDSA have almost completely remolded the original ECDSA signing operation by heavy MPC technique, which makes it difficult to be embedded in the existing ECDSA applications. Motivated by the above discussions, we ask the following challenging questions:\\


\begin{minipage}{0.95\textwidth}
\begin{center}
\emph{Without complicated MPC techniques, whether there is a simple yet fast two-party signing protocol based on the ECDSA?}
\end{center}
\end{minipage}


\subsection{Our Contributions}

In this paper, we give a positive answer to the above question. First, we propose a variant of ECDSA called combinatorial ECDSA, and prove its security based on ECDSA itself. The Combinatorial ECDSA can be viewed as a combination of two ECDSA signatures and can easily be split into two parts. Then, benefiting from the structure of combinatorial ECDSA, we design a simple and fast two-party signing protocol without complicated MPC techniques, which can also be proven secure based on the ECDSA security. 

\begin{trivlist}
\item \textbf{Combinatorial ECDSA.} From our observation that two ECDSA signatures generated by different signing keys and the same random number can be easily combined into a secure signature, we can construct the combinatorial ECDSA. Intuitively speaking, the signing key of our combinatorial ECDSA contains of two-part ECDSA signing keys $x_1,x_2$, and the verification key contains of $Q_{\text{add}}=(x_1+x_2)\cdot G,Q_{\text{mul}}=x_1\cdot x_2\cdot G$ which is the combination of two ECDSA verification keys $Q_1=x_1\cdot G,Q_2=x_2\cdot G$, and the combinatorial ECDSA signature $s=k^{-1}(H(m)+rx_1)(H(m)+rx_2) \bmod q$ can be simply viewed as a multiplication of two ECDSA signature. 

We can prove its security based on ECDSA. Informally, in the security proof, the simulator $\mathcal{S}$ can use the ECDSA signing oracle to simulate the signing oracle of the combinatorial ECDSA. $\mathcal{S}$ can choose a part of signing key $x_2$ and use ECDSA verification key $Q_1=x_1\cdot G$ to simulate the combinatorial ECDSA verification key $Q_{\text{add}}=Q+x_2\cdot G,Q_{\text{mul}}=x_2\cdot Q$, and simulate the signing oracle of the combinatorial ECDSA by querying the ECDSA signing oracle for message $m$ to get an ECDSA signature $\sigma=(r,s)$ and compute the combinatorial ECDSA signature $\sigma'=(r,s\cdot (H(m)+rx_2)\bmod q)$.
\end{trivlist}

\begin{trivlist}
\item \textbf{Two-party signature.} The Combinatorial ECDSA can be viewed as a combination of two ECDSA signatures. The special structure makes it easy to be split into two pieces and each piece also preserves the structure of ECDSA, at the same time, it can remain the security of ECDSA. Based on the combinatorial ECDSA, we design a two-party signing protocol without complicated MPC techniques, which can also be proven secure based on the ECDSA. 

Informally speaking, in our two-party signing protocol, each party takes advantage of a zero-knowledge proof of knowledge of discrete logarithm functionality to ensure that a point $R=k_1\cdot k_2 \cdot G$ is uniformly distributed, and then based on this point each party gives ECDSA signature $s_1=k_1^{-1}(H(m)+r\cdot x_1)\bmod q$ and $s_2=k_2^{-1}(H(m)+r\cdot x_2)\bmod q$ respectively, where $(r_x,r_y)=R, r=r_x\bmod q$, and $k_1,k_2$ is the random number chosen by each party. The combinatorial ECDSA $s=s_1\cdot s_2 \bmod q$ can be combined by computing the multiplication of two ECDSA signature $s_1,s_2$. We can instantiate the zero-knowledge proof functionality efficiently by the Schnorr proof~\cite{Sch89} and the Fiat-Shamir transform~\cite{FS86}. 
 
Benefiting from the structure of combinatorial ECDSA, a whole signature can be easily combined from two ECDSA signature. Two main difficult problems of constructing distributed ECDSA were avoided, (i) inverted shared secret $k^{-1}=k_1^{-1}\cdot k_2^{-1}$, and (ii) computed the multiplication $k^{-1}\cdot x=k_1^{-1}\cdot k_2^{-1}\cdot x_1\cdot x_2$ of shared secrets $(k_1,x_1)$ and $(k_2,x_2)$. In previous two-party ECDSA~\cite{MR01,Lin17,DKLs18,CCLST19}, above two problems need to be solved by using heavy MPC techniques and expensive zero-knowledge proofs. Therefore, our two-party signing protocol is more efficient than existing two-party signature based on ECDSA.
\end{trivlist}

\begin{trivlist}
\item \textbf{Upgrade to the two-party scenario easily.} 
In our protocol, the signing operation of each party is similar to the original ECDSA, and the signing results outputted by each party preserve the structure of the ECDSA signature, which can be verified easily by using the ECDSA verification algorithm and avoid expensive zero-knowledge proofs. Therefore, compared with the existing two-party ECDSA~\cite{MR01,Lin17,DKLs18,CCLST19}, our scheme can achieve the same good performance as ECDSA, and reuses the implementation of ECDSA greatly and upgrades the existing ECDSA application to the two-party scenario friendly. 

To be specific, extending two-party scenarios from existing ECDSA applications, both parties in our two-party signing protocol can compute random point $R$ together offline. After receiving a message $m$ online, both parties can run the underlying ECDSA signing component to generate the ECDSA signature, respectively. Both signing values can be verified by using the ECDSA verification algorithm and can be combined into the combinatorial ECDSA signature directly. To upgrade the two-party scenario from the existing ECDSA application, our protocol does not modify the underlying ECDSA signing structure and can reuse the implementation of ECDSA greatly. 
\end{trivlist}

\begin{trivlist}
\item \textbf{Performance.} We show the theoretical analysis of our combinatorial ECDSA and two-party signature. Our schemes can achieve the same level of efficiency as ECDSA. By avoiding heavy MPC tools, our protocol can use efficient zero-knowledge proof~\cite{Sch89,FS86} rather than expensive zero-knowledge proofs used in previous schemes~\cite{MR01,Lin17,DKLs18,CCLST19}. In particular, additional zero-knowledge proof can be run in the offline signing phase. What's more, we realize our schemes based on the OpenSSL, and the running times of all algorithms in combinatorial ECDSA and two-party signing protocol are the levels of microseconds. Therefore, our protocol is more efficient than previous schemes~\cite{Lin17,CCLST19}, where the running times of the key generation and signing operation are at least the level of millisecond depicted in~\cite{CCLST19}.
\end{trivlist}

\section{Preliminaries}
\subsection{Notations}

For $n\in \mathbb{N}$, $1^n$ denotes the string of $n$ ones. If $S$ is a set then $s\leftarrow S$ denotes the operation of sampling an element $s$ of $S$ at random. A function is negligible in $\lambda$, written $\mathsf{negl}(\lambda)$, if it vanishes faster than the inverse of any polynomial in $\lambda$.

\subsection{Signature}

A signature system consists of three algorithms $\Pi = (\mathsf{KeyGen},\mathsf{Sign},\mathsf{Vrfy})$. 

\begin{itemize}
\item $\mathsf{KeyGen}(1^\lambda)\rightarrow (vk,sk)$. The key generation algorithm takes the security parameter as input and outputs a verification key $vk$ and a secret key $sk$.
\item $\mathsf{Sign}(sk,m)\rightarrow \sigma$. The signing algorithm takes the secret key $sk$ and the message $m\in \mathcal{M}$ (where $\mathcal{M}$ is some fixed
message space, possibly depending on $n$)  as input, and outputs a signature $\sigma$. 
\item $\mathsf{Vrfy}(vk,m,\sigma)\rightarrow 0/1$. The verification algorithm takes the verification key $vk$, the message $m\in \mathcal{M}$, and the signature $\sigma$ as input, and outputs either $0$ or $1$.
\end{itemize}

\begin{trivlist}
\item \textbf{Correctness.} The standard completeness requirement is that for any $(vk$, $sk)$ $\leftarrow$ $\mathsf{KeyGen}(1^\lambda)$ and any $m\in \mathcal{M}$, we have $\mathsf{Vrfy}(vk, m, \mathsf{Sign}(sk, m)) \rightarrow 1$.
\end{trivlist}

\begin{trivlist}
\item \textbf{Security.} Let $\mathcal{A}$ be a probabilistic polynomial-time (PPT) adversary against the existentially unforgeable under chosen message attacks (EUF-CMA). Its advantage function $\mathbf{Adv}^{\text{euf-cma}}_{\Pi,\mathcal{A}}(1^\lambda)$ is defined as

\begin{equation*}
\begin{aligned}
\Pr\left[\mathsf{Vrfy}(vk,m^*,\sigma^*) = 1:\begin{array}{l}
                  (vk,sk) \leftarrow \mathsf{KeyGen}(1^\lambda);  \\
                  (m^*, \sigma^*)\leftarrow \mathcal{A}^{\mathsf{Sign}(sk,\cdot)}(1^\lambda,vk); \\
                \end{array}
\right]
\end{aligned}
\end{equation*}

Here, $\mathsf{Sign}(sk,\cdot)$ provides access to signing oracle with respect to $sk$. More precisely, $\mathsf{Sign}(sk,\cdot)$ returns $\mathsf{Sign}(sk,m)$ on input any $m\in \mathcal{M}$. $\mathcal{Q}$ be the set of all $m$ queried by $\mathcal{A}$ to its oracle, $m^*\notin \mathcal{Q}$.  The signature is EUF-CMA if no PPT adversary $\mathcal{A}$ has non-negligible advantage in the above security experiment.
\end{trivlist}


\subsection{ECDSA} 
Let $\mathbb{G}$ be an Elliptic curve group of order $q$ with base point (generator) $G$, and $pp=(\mathbb{G},q,G)$ is the public parameter. $\mathsf{H}$ denotes the hash function, such as $\mathsf{SHA}\text{-}256$. ECDSA algorithm~\cite{ECDSA} on a message $m\in \{0,1\}^*$ is defined as follows. 
\begin{itemize}
\item $\mathsf{KeyGen}(pp)\rightarrow (Q,x)$: uniformly choose a secret signing key $x\leftarrow \mathbb{Z}_q$, calculate the verification key $Q=x\cdot G$.
\item $\mathsf{Sign}(x,m)\rightarrow (r,s)$:
\begin{itemize}
\item[1.] Compute $m'\leftarrow \mathsf{H}(m)$
\item[2.] Choose a random $k \leftarrow\mathbb{Z}_q$
\item[3.] Compute $R =k \cdot G$. Let $R = (r_x,r_y)$ and compute $r = r_x \bmod q$. If $r = 0$, go back to Step 2
\item[4.] Compute $s' = k^{-1} \cdot (m'  + r\cdot x) \bmod q$, sets $s=\min\{s',q-s'\}$, and output $\sigma=(r,s)$
\end{itemize}
\item $\mathsf{Vrfy}(Q,m,\sigma)\rightarrow 0/1$:
\begin{itemize}
\item[1.] Compute $m'\leftarrow \mathsf{H}(m)$, $(r_x',r_y')=s^{-1}\cdot (m'\cdot G+r\cdot Q)$
\item[2.] If $r=r_x'\bmod q$, output $1$, otherwise, output $0$
\end{itemize}
\end{itemize}

\subsection{Two-Party Signature}
The two-party signature~\cite{Lin17,CCLST19} contains distributed key generation protocol, distributed signing protocol, and verification algorithm. Two parties run distributed key generation protocol together to generate the shared signing key respectively and the verification key. After getting any message, two parties run the distributed signing protocol together to compute a signature. The signature can be verified by using the verification algorithm. 

We review the security of two-party signature following~\cite{Lin17,CCLST19}. In the experiment of distributed signature 
$\text{Expt\text{-}DSign}_{\mathcal{A},\Pi^b_2}$,\ $b\in\{1,2\}$ , a PPT adversary $\mathcal{A}$ corrupting the party $\text{P}_b$ in protocol $\Pi_2$ can interact with an oracle $\Pi_2^b(\cdot,\cdot)$ to sign any messages concurrently, which executes as another party $\text{P}_{3-b}$. $\Pi_2^b(\cdot,\cdot)$ is defined such that the distributed key generation is first run once and then the signing protocols can be executed concurrently. The oracle receives two inputs: the first is a session identifier and the second is either an input or a next message. It works as follows: 

In the key generation phase: 
\begin{itemize}
\item Upon receiving $(0,0)$ first, the oracle initializes a machine $M$ and acts as the party $\text{P}_{3-b}$ to reply. 
\item Upon receiving $(0,m)$, the oracle hands $M$ the message $m$ as its next incoming message and returns $M$'s reply. 
\item Upon receiving $(sid,m)$ is received where $sid \not= 0$, the oracle returns $\bot$.
\end{itemize}

In the signing phase:
\begin{itemize}
\item Upon receiving $(sid,m)$, and this is the first oracle query with this identifier $sid$, the oracle initializes a new machine $M_{sid}$ with the key share and any state stored by $M$ at the end of the key generation phase. The $M_{sid}$ executes as the party $\text{P}_{3-b}$ with session identifier $sid$ and input message $m$ to be signed.  
\item Upon receiving $(sid,m)$, and this is not the first oracle query with this identifier $sid$, the oracle hands $M_{sid}$ the incoming message $m$ and returns the next message sent by $M_{sid}$. If $M_{sid}$ concludes, then the output obtained by $M_{sid}$ is returned.
\end{itemize}

The adversary $\mathcal{A}$ controlling $\text{P}_b$ with oracle access to $\Pi_2^b(\cdot,\cdot)$ ``wins'' if it can forge a signature on a message that is not queried. For a detailed explanation we refer the reader to~\cite{Lin17}. Let $\Pi_2 = (\mathsf{IKeyGen},\mathsf{ISign},\mathsf{Vrfy})$ be a two-party signature, where the $\mathsf{IKeyGen}$ denotes two-party key generation protocol, and the $\mathsf{ISign}$ denotes two-party signing protocol.
The experiment 
$\text{Expt\text{-}DSign}_{\mathcal{A},\Pi^b_2}$,\ $b\in\{1,2\}$ is defined as follows.

Let $\mathcal{A}$ be a PPT adversary against two-party signature $\Pi^b_2$. Its advantage function $\mathbf{Adv}_{\Pi^b_2,\mathcal{A}}(1^\lambda)$ is defined as
\begin{equation*}
\begin{aligned}
\Pr\left[\mathsf{Vrfy}(vk,m^*,\sigma^*) = 1:(m^*, \sigma^*)\leftarrow \mathcal{A}^{\Pi_2^b(\cdot,\cdot)}(1^\lambda)
\right]
\end{aligned}
\end{equation*}
Let $\mathcal{Q}$ be the set of all inputs $m$ such that $(sid,m)$ was queried by $\mathcal{A}$ to its oracle $\Pi_2^b(\cdot,\cdot)$ as the first query with identifier $sid \not= 0$, $m^*\notin \mathcal{Q}$. $\mathsf{Vrfy}(vk,m^*,\sigma^*) = 1$, where $vk$ is the verification key output by $\text{P}_{3-b}$ from the key generation phase, and $\mathsf{Vrfy}$ is as specified in $\Pi_2$. The two-party signing protocol is secure if no PPT adversary $\mathcal{A}$ has non-negligible advantage in the above security experiment.


\subsection{Ideal Functionalities}

We review three ideal functionalities used in~\cite{Lin17,CCLST19}, including the ideal commitment functionality $\mathcal{F}_{\text{com}}$, the ideal zero-knowledge functionality $\mathcal{F}_{\text{zk}}$, and the committed non-interactive zero-knowledge functionality $\mathcal{F}^\mathsf{R}_{\text{com\text{-}zk}}$. For a detailed explanation of these ideal functionalities we refer the reader to~\cite{Lin17}.

The ideal commitment functionality $\mathcal{F}_{\text{com}}$~\cite{Lin11,Fuj16} works with parties $\text{P}_1$ and $\text{P}_2$, formally defined as follows.
\begin{center}
\fbox{\parbox{0.9\textwidth}{
\begin{itemize}
\item Upon receiving $(\mathsf{commit},sid,x)$ from party $\text{P}_i$ (for $i \in \{1,2\}$), record $(sid,i,x)$ and send $(\mathsf{receipt},sid)$ to party $\text{P}_{3-i}$ . If $(\mathsf{commit},sid,*)$ is already stored, then ignore the message.
\item Upon receiving $(\mathsf{decommit},sid)$ from party $\text{P}_i$, if $(sid,i,x)$ is recorded then send $(\mathsf{decommit},sid,x)$ to party $\text{P}_{3-i}$.
\end{itemize}}}
\end{center}

A standard ideal zero-knowledge functionality~\cite{HL10} is defined by $((x,w)$, $\lambda)$ $\leftarrow$ $(\lambda,(x,\mathsf{R}(x,w)))$, where $\lambda$ denotes the empty string. For a relation $\mathsf{R}$, the ideal zero-knowledge functionality is denoted by $\mathcal{F}^\mathsf{R}_{\text{zk}}$, formally defined as follows. 
\begin{center}
\fbox{\parbox{0.9\textwidth}{
\begin{itemize}
\item Upon receiving $(\mathsf{prove},sid,x,w)$ from a party $\text{P}_i$ (for $i \in \{1,2\}$): if $(x,w)\notin \mathsf{R}$ or $sid$ has been previously used then ignore the message. Otherwise, send $(\mathsf{proof},sid,x)$ to party $\text{P}_{3-i}$.
\end{itemize}}}
\end{center}

For a relation $\mathsf{R}$, the commitments to non-interactive zero-knowledge proofs of knowledge used by the ideal commitment functionality $\mathcal{F}_{\text{com}}$ is denoted by $\mathcal{F}^\mathsf{R}_{\text{com\text{-}zk}}$, formally defined as follows.
\begin{center}
\fbox{\parbox{0.9\textwidth}{
\begin{itemize}
\item Upon receiving $(\mathsf{com\text{-}prove},sid,x,w)$ from a party $\text{P}_i$ (for $i \in \{1,2\}$): if $(x,w) \notin R$ or $sid$ has been previously used then ignore the message. Otherwise, store $(sid,i,x)$ and send $(\mathsf{proof\text{-}receipt},sid)$ to $\text{P}_{3-i}$.
\item Upon receiving $(\mathsf{decom\text{-}proof},sid)$ from a party $\text{P}_i$ (for $i\in \{1,2\}$): if $(sid,i,x)$ has been stored then send $(\mathsf{decom\text{-}proof},sid,x)$ to $\text{P}_{3-i}$ 
\end{itemize}}}
\end{center}

\section{The Combinatorial ECDSA Based on ECDSA}

In this section, we construct the combinatorial ECDSA (cECDSA), which consists of three algorithms $\Pi_1 = (\mathsf{KeyGen}$,$\mathsf{Sign}$,$\mathsf{Vrfy})$ defined as follows. Let $\mathbb{G}$ be an Elliptic curve group of order $q$ with base point (generator) $G$, and $pp=(\mathbb{G},q,G)$ is the public parameter. $\mathsf{H}$ denotes the hash function, like ECDSA. 
\begin{itemize}
\item $\mathsf{KeyGen}(pp)\rightarrow (Q,x)$: uniformly choose $x_1,x_2\leftarrow \mathbb{Z}_q$, calculate $Q_1=x_1\cdot G,Q_2=x_2\cdot G,Q_\text{add}=Q_2+Q_1,Q_\text{mul} = x_1\cdot x_2\cdot G$.
The secret signing key is $x=(x_1,x_2)$ and the verification key is $Q=(Q_\text{add},Q_\text{mul})$.
\item $\mathsf{Sign}(x,m)\rightarrow (r,s)$: 
\begin{itemize}
\item[1.] Compute $m'\leftarrow \mathsf{H}(m)$
\item[2.] Choose a random $k \leftarrow\mathbb{Z}_q$, compute $R= k \cdot G$, and let $R = (r_x,r_y)$
\item[3.] Compute $r = r_x \bmod q$. If $r = 0$, go back to Step 2
\item[4.] Compute $s' =  k^{-1} \cdot (m'  + r\cdot x_1)\cdot (m'  + r\cdot x_2) \bmod q$, sets $s=\min\{s',q-s'\}$, and output $(r,s)$
\end{itemize}
\item $\mathsf{Vrfy}(Q,m,\sigma)\rightarrow 0/1$: 
\begin{itemize}
\item[1.] Compute $m'\leftarrow \mathsf{H}(m)$, and $(r_x',r_y')=s^{-1}\cdot (m'^{2}\cdot G+r\cdot m'\cdot Q_\text{add}+r^2\cdot Q_\text{mul})$
\item[2.] If $r=r_x'\bmod q$, output $1$, otherwise, output $0$
\end{itemize}
\end{itemize}

\begin{trivlist}
\item \textbf{Correctness.} For any $\mathsf{KeyGen}(pp)\rightarrow (Q,x)$ and $m\in\{0,1\}^*$, the signature is $\sigma=(r,s)$, where $r = r_x \bmod q$, $(r_x,r_y)=k \cdot G$, $s =  k^{-1} \cdot (m'  + r\cdot x_1)\cdot (m'  + r\cdot x_2) \bmod q$. We can verify the signature as follows.
\begin{equation*}
\begin{aligned}
s^{-1}(m'^{2}\cdot G+r\cdot m'\cdot Q_\text{add}+r^2\cdot Q_\text{mul})&=s^{-1} (m'^{2}+r\cdot m'\cdot(x_1+x_2)+r^2\cdot x_1\cdot x_2)\cdot G\\
&=s^{-1}\cdot(m'+r \cdot x_1)(m'+r \cdot x_2)\cdot G\\
&=k\cdot G
\end{aligned}
\end{equation*} 
Therefore, $(r_x',r_y')=k\cdot G$, $r=r_x'\bmod q$, $\mathsf{Vrfy}(Q,m,\sigma)\rightarrow 1$. The combinatorial ECDSA satisfies the correctness.
\end{trivlist}

\begin{lemma} 
Our combinatorial ECDSA defined above is existentially unforgeable under chosen-message attacks if ECDSA is secure.
\end{lemma}

\begin{proof}
Our proof works by showing that, for any PPT adversary $\mathcal{A}$ breaking the EUF-CMA security of the combinatorial ECDSA with non-negligible probability, we can construct a PPT reduction algorithm $\mathcal{S}$ who can break the EUF-CMA security of ECDSA with non-negligible probability.

Assume that $\mathcal{A}$ can output a new combinatorial ECDSA signature $(r,s)$ with non-negligible probability $\varepsilon(\lambda)$ as follows: 
$$\mathbf{Adv}^{\text{euf-cma}}_{\text{cECDSA},\mathcal{A}}(1^\lambda)=\Pr[\text{Expt-cECDSA}_{\mathcal{A}}(1^\lambda)=1]=\varepsilon(\lambda).$$
Then, we use $\mathcal{A}$ to build a reduction algorithm $\mathcal{S}$ to break the security of ECDSA. That is, $\mathcal{S}$ is given an ECDSA verification key $Q_1 = x_1\cdot G$ as input and tries to give a new ECDSA signature with the help of an ECDSA signing oracle $\mathcal{O}(\cdot)$ that takes in any message and outputs an ECDSA signature. $\mathcal{S}$ works as follows: 
\begin{itemize}
\item[1.] Choose a random value $x_2\leftarrow \mathbb{Z}_q$ and compute $Q_2=x_2\cdot G, Q_\text{add}=Q_1+Q_2,Q_\text{mul}=x_2\cdot Q_1,Q=(Q_\text{add},Q_\text{mul})$.
\item[2.] Run $\mathcal{A}$ on input the verification key $Q$. When $\mathcal{A}$ makes a query of any message $m_i$ to the combinatorial ECDSA signing oracle $\mathcal{O}_1$, $\mathcal{S}$ makes a query of message $m_i$ to the ECDSA signing oracle $\mathcal{O}$ and gets an ECDSA signature $\sigma_i=(r_i,s_i=k_i^{-1}(r_i\cdot x_1+m_i'))$. Then $\mathcal{S}$ can compute a combinatorial ECDSA signature $\sigma_i'=(r_i,s_i'=k_i^{-1}(r_i\cdot x_1+m_i')(r_i\cdot x_2+m_i'))$ and reply the signature $\sigma_i'$ to $\mathcal{A}$. 
\item[3.]  When $\mathcal{A}$ outputs a new combinatorial ECDSA signature $\sigma'=(r,s=k^{-1}(r\cdot x_1+m')(r\cdot x_2+m'))$ of a message $m$. Then, $\mathcal{S}$ can outputs a new ECDSA signature $\sigma=(r,s(r\cdot x_2+m')^{-1}=k^{-1}(r\cdot x_1+m'))$. 
\end{itemize}
As we can see, $\mathcal{S}$ gives a perfect simulation of $\mathcal{A}$'s views in the experment-cECDSA.  
Since $\mathcal{A}$ outputs a new combinatorial ECDSA signature with non-negligible probability $\varepsilon(\lambda)$, 
$\mathcal{S}$ can also output a forge of ECDSA with non-negligible probability $\varepsilon(\lambda)$ in the experiment-ECDSA. Its advantage function: 
$$\mathbf{Adv}^{\text{euf-cma}}_{\text{ECDSA},\mathcal{S}}(1^\lambda)=\Pr[\text{Expt-ECDSA}_{\mathcal{S}}(1^\lambda)=1]=\varepsilon(\lambda).$$
We conclude that $\mathcal{S}$ can break the EUF-CMA security of ECDSA, a contradiction. Therefore, combinatorial ECDSA defined above is existentially unforgeable under chosen message attacks. \qed
\end{proof}



\section{Two-Party Signature}

In this section, we present our two-party combinatorial ECDSA (TP-cECDSA) based on ECDSA. 
Following~\cite{Lin17}, our protocol is also presented in the $\mathcal{F}_{\text{zk}}$ and $\mathcal{F}_{\text{com-zk}}$ hybrid model. We use zero-knowledge functionality $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$~\cite{Lin17} for the relation $\mathsf{R}_{\text{DL}} = \{(\mathbb{G},G,q,P,w) | P = w \cdot G\}$ of discrete log values (relative to the given group). We use the standard Schnorr proof~\cite{Sch89,FS86} for this. For convenience, we omit the group description $(\mathbb{G},G,q)$ and assume that all values (Elliptic curve points) received are not equal to $0$, and each party receiving zero aborts.

\subsection{Distributed Key Generation}
The parties together generate a tuple of random group element $Q$. $\text{P}_1$ chooses a random number $x_1$, computes and sents a random point $Q_1 = x_1 \cdot G$ along with a zero-knowledge proof of knowledge to $\text{P}_2$.  $\text{P}_2$ also chooses a random number $x_2$, computes and sends $Q_2 = x_2 \cdot G$ along with a zero-knowledge proof of knowledge to $\text{P}_1$. The output is the point tuple $Q=(Q_\text{add},Q_\text{mul})$, where $Q_\text{add}= Q_1+Q_2,Q_\text{mul}= x_1\cdot x_2\cdot G$. See Protocol 1 for a full description.

The protocol 1 is simulatable. In particular, assume that $\text{P}_1$ is corrupted. A simulator can define the value sent by $\text{P}_2$ to be $Q_2 = Q_{\text{ECDSA}}$, where $Q_{\text{ECDSA}}$ is the verification key in the experiment-ECDSA. If $\text{P}_2$ is corrupted, a simulator can define the value sent by $\text{P}_1$ to be $Q_1 = Q_{\text{ECDSA}}$.

\begin{center}
\fbox{\parbox{1\textwidth}{
PROTOCOL 1.  (Key Generation Protocol $\mathsf{IKeyGen}$$(pp)$)
Given input $pp=(\mathbb{G},G,q)$ and security parameter $1^\lambda$, work as follows:
\begin{itemize}
\item[1.] $\text{P}_1$'s first message:
\begin{itemize}
\item[(a)] $\text{P}_1$ runs $\text{ECDSA}.\mathsf{KeyGen}(pp)\rightarrow (x_1, Q_1=x_1\cdot G)$.
\item[(b)] $\text{P}_1$ sends $(\mathsf{prove},1,Q_1,x_1)$ to$\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$.
\end{itemize}
\item[2.] $\text{P}_2$'s first message:
\begin{itemize}
\item[(a)] $\text{P}_2$ receives $(\mathsf{proof},1,Q_1)$ from $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$. If not, it aborts.
\item[(b)] $\text{P}_2$ runs $\text{ECDSA}.\mathsf{KeyGen}(pp)\rightarrow (x_2, Q_2=x_2\cdot G)$.
\item[(c)] $\text{P}_2$ sends $(\mathsf{prove},2,Q_2,x_2)$ to$\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$.
\end{itemize}
\item[3.] $\text{P}_1$'s verification:
\begin{itemize}
\item[(a)] $\text{P}_1$ receives $(\mathsf{proof},2,Q_2)$ from $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$. If not, it aborts.
\end{itemize}
\item[4.] Output:
\begin{itemize}
\item[(a)] $\text{P}_1$ computes $Q_\text{add}=Q_2+Q_1,Q_\text{mul} = x_1\cdot Q_2,Q=(Q_\text{add},Q_\text{mul})$ and stores $(x_1,Q)$.
\item[(b)] $\text{P}_2$ computes $Q_\text{add}=Q_2+Q_1,Q_\text{mul} = x_2\cdot Q_1,Q=(Q_\text{add},Q_\text{mul})$ and stores $(x_2,Q)$.
\end{itemize}
\end{itemize}}}
\end{center}

\subsection{Two-Party Signing Protocol} 
The main idea of our two-party signing protocol is as follows. First, both parties run a similar ``coin tossing protocol'' in order to obtain a random point $R$ that will be used in generating the signature. After this, the parties $\text{P}_1$ and $\text{P}_2$ hold the random number $k_1$ and $k_2$, respectively, where $R = k_1 \cdot k_2 \cdot G=(r_x,r_y),r=r_x$. Then, the parties receive the message $m$. $\text{P}_2$ can compute part of signature $(r,k_2^{-1}(r\cdot x_2+\mathsf{H}(m)))$, and $\text{P}_1$ can compute another part of signature $(r,k_1^{-1}(r\cdot x_1+\mathsf{H}(m)))$. Both parts of signature can be easily verified and can be combined into a cECDSA signature.

In the signing protocol, $\text{P}_1$ and $\text{P}_2$ first take in the signing key and the message $m$, and a unique session id $sid$, and then verify that $sid$ has not been used before (if it has been, the protocol is not executed). 

\begin{center}
\fbox{\parbox{1\textwidth}{
PROTOCOL 2. (Signing Protocol $\mathsf{ISign}(sid,m)$) Given the outputted from Protocol 1 and the message $m$, and a unique session id $sid$ as input. Protocol 2 is described as follows:
\begin{itemize}
\item[1.] $\text{P}_1$'s first message:
\begin{itemize}
\item[(a)] $\text{P}_1$ chooses a random $k_1 \leftarrow \mathbb{Z}_q$ and computes $R_1 = k_1 \cdot G$.
\item[(b)] $\text{P}_1$ sends $(\mathsf{com\text{-}prove},sid||1,R_1,k_1)$ to $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{com-zk}}$ .
\end{itemize}
\item[2.] $\text{P}_2$'s first message:
\begin{itemize}
\item[(a)] $\text{P}_2$ receives $(\mathsf{proof\text{-}receipt},sid||1)$ from $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{com-zk}}$.
\item[(b)] $\text{P}_2$ chooses a random $k_2 \leftarrow \mathbb{Z}_q$ and computes $R_2 = k_2 \cdot G$.
\item[(c)] $\text{P}_2$ sends $(\mathsf{prove},sid||2,R_2 ,k_2 )$ to $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$.
\end{itemize}
\item[3.] $\text{P}_1$'s second message:
\begin{itemize}
\item[(a)] $\text{P}_1$ receives $(\mathsf{proof},sid||2,R_2)$ from $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$; if not, it aborts.
\item[(b)] $\text{P}_1$ sends $(\mathsf{decom\text{-}proof},sid||1)$ to $\mathcal{F}_{\text{com\text{-}zk}}$.
\end{itemize}
\item[4.] $\text{P}_2$'s second message:
\begin{itemize}
\item[(a)] $\text{P}_2$ receives $(\mathsf{decom\text{-}proof},sid||1,R_1)$ from $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$; if not, it aborts.
\item[(b)] $\text{P}_2$ computes $R = k_2 \cdot R_1$. Denote $R = (r_x,r_y )$. After receiving $m$, $\text{P}_2$ computes $r = r_x \bmod q$,$s_2=k_2^{-1}(r\cdot x_2+\mathsf{H}(m))\bmod q$.
\item[(c)] $\text{P}_2$ sends $s_2$ to $\text{P}_1$.
\end{itemize}
\item[5.] $\text{P}_1$ generates output:
\begin{itemize}
\item[(a)] $\text{P}_1$ computes $R = k_1 \cdot R_2$. Denote $R = (r_x,r_y)$. Then, $\text{P}_1$ computes $r = r_x \bmod q$.
\item[(b)] $\text{P}_1$ computes $s'=k_{1}^{-1}(r\cdot x_1+\mathsf{H}(m))\cdot s_2\bmod q$, and sets $s=\min\{s',q-s'\}$ (this ensures that the signature is always the smaller of the two possible values).
\item[(c)] $\text{P}_1$ verifies that $(r,s)$ is a valid signature with public key $Q$. If yes it outputs the cECDSA signature $(r,s)$; otherwise, it aborts.
\end{itemize}
\end{itemize}}}
\end{center}

\begin{trivlist}
\item \textbf{Offline/Online.} As we can see, the first three steps in the above signing protocol run by two parties are used to agree on the random point $R=k_1\cdot k_2 \cdot G$, and the message to be signed is only used in the last step. Thus, it is possible to run the first three steps to pre-store many random points in the offline phase. In the online signing phase, after receiving the message $m$, each party can take advantage of stored random points to compute signatures together. As is shown in our protocol 2, the signing operation of $\text{P}_1$ and $\text{P}_2$ is similar to the original signing operation of ECDSA \footnote{In offline/online mode of ECDSA, the signer can pre-store many random numbers and compute the random points in the offline, and then he uses the stored random numbers and points to sign any messages in the online.}.   
\end{trivlist}

\begin{trivlist}
\item \textbf{Output to both parties, or a combiner.} Observe that since the validity of the signature can be checked by any other parties, it is possible for $\text{P}_1$ to send $\text{P}_2$ part of a signature, or even both $\text{P}_1$ and $\text{P}_2$ to send combiner \footnote{In the threshold signature, there always exists a combiner~\cite{BGGJKRS18} that can combine every part of signature sent from each party into a whole signature.} part of a signature without verifying the part of signature sent by another party. Since every part of the signature can be seen as an ECDSA signature, this will not affect security at all. In particular, the combiner can easily combine the whole cECDSA signature and verifies its validation by running the verification algorithm of cECDSA.    
\end{trivlist}

\subsection{Proof of Security}

In this section, we prove that $\Pi_2$ comprised of Protocols 1 and 2 for key generation and signing, respectively, constitutes a secure two-party signing protocol. Our proof of security based on the hybrid model with ideal functionalities $\mathcal{F}_{\text{com}}$, $\mathcal{F}_{\text{zk}}$, $\mathcal{F}^\mathsf{R}_{\text{com\text{-}zk}}$~\cite{Lin17,Can00,Can01}.

\begin{lemma} 
Assume that ECDSA is existentially unforgeable under chosen-message attack and that the zero-knowledge proofs and commitments are as described. Then, Protocols 1 and 2 constitute a secure two-party signing protocol.
\end{lemma}

\begin{proof}
We separately prove security for the case of a corrupted $\text{P}_b,b\in\{1,2\}$ and define two hybrid experiments Game$_{1_b}$, Game$_{2_b}$ as follows.
\begin{trivlist}
\item Game$_{1_b}$: The PPT adversary $\mathcal{A}$ corrupts $\text{P}_b,b\in\{1,2\}$. Another party $\text{P}_{3-b}$ interacts with  $\mathcal{A}$ in real execution of protocol 1 and 2.
\end{trivlist}
\begin{trivlist}
\item Game$_{2_b}$: The PPT adversary $\mathcal{A}$ corrupts $\text{P}_b,b\in\{1,2\}$. We construct a PPT simulator $\mathcal{S}$ to interact with $\mathcal{A}$ like $\text{P}_{3-b}$ in Game$_{1_b}$, except that $\mathcal{S}$ sets the verification key $Q^*$ in experiment-ECDSA as $Q_{3-b}$ in the experiment-TP-cECDSA and interacts with $\mathcal{A}$ based on the ECDSA signing oracle. 
\end{trivlist}
In Game$_{2_1}$, there exist a PPT adversary $\mathcal{A}$ that corrupts $\text{P}_1$. We construct a PPT simulator $\mathcal{S}$ to simulates the execution for $\mathcal{A}$. Formally:

\begin{enumerate}
\item[1.] $\mathcal{S}$ takes $(1^\lambda,Q^*)$ as input and has the access to the signing oracle of the experiment ECDSA, where $Q^*$ is the public verification key in experiment ECDSA.

\item[2.] $\mathcal{S}$ runs $\mathcal{A}$ on input $1^\lambda$ and simulates oracle $\Pi^1_2$ for $\mathcal{A}$, answering as described in the following steps:

\begin{enumerate}
\item[a)] $\mathcal{S}$ replies $\bot$ to all queries from $\mathcal{A}$ before it queries $(0,0)$. 

\item[b)] After $\mathcal{A}$ sends $(0,0)$ to the oracle $\Pi^1_2$, $\mathcal{S}$ receives $(0,m_1)$ which is $\text{P}_1$'s first message in the key generation subprotocol (any other query is ignored). $\mathcal{S}$ computes the oracle reply as follows:

\begin{enumerate}
\item[i.] $\mathcal{S}$ parses $m_1$ into the form $(\mathsf{prove},1,Q_1,x_1)$  that $\text{P}_1$ sends to $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$ in the hybrid model.

\item[ii.] $\mathcal{S}$ verifies that $Q_1 = x_1\cdot G$. If yes, then it sets $Q_2 =Q^*$. Then $\mathcal{S}$ sets the oracle reply of $\Pi^1_2$ to be $(\mathsf{proof},2,Q_2)$ and internally hands this to $\mathcal{A}$ (as if sent by $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$).

\end{enumerate}
\item[c)] Finally, $\mathcal{A}$ can compute $Q_\text{add}=Q_2+Q_1=Q^*+Q_1,Q_\text{mul} = x_1\cdot Q_2,Q=(Q_\text{add},Q_\text{mul})$ and stores $(x_1,Q)$. $\mathcal{S}$ can compute $Q_\text{add}=Q_2+Q_1,Q_\text{mul} = x_1\cdot Q_2,Q=(Q_\text{add},Q_\text{mul})$ and stores $(x_1,Q)$. The distributed key generation phase is completed.

\item[d)] Upon receiving a query of the form $(sid,m)$ where $sid$ is a new session identifier, $\mathcal{S}$ queries its signing oracle in experiment-ECDSA with $m$ and receives back an ECDSA signature $(r,s)$. Using the ECDSA verification procedure, $\mathcal{S}$ computes the Elliptic curve point $R$.  Then, queries received by $\mathcal{S}$ from $\mathcal{A}$ with identifier $sid$ are processed as follows:

\begin{enumerate}
\item[i.] The first message $(sid,m_1)$ is processed by first parsing the message $m_1$ as $(\mathsf{com\text{-}prove}$,
$sid||1$,$R_1$,$k_1)$. If $R_1 = k_1\cdot G$ then $\mathcal{S}$ sets $R_2 =k_1^{-1}\cdot R$; else it chooses $R_2$ at random. $\mathcal{S}$ sets the oracle reply to $\mathcal{A}$ to be the message $(\mathsf{proof}$,
$sid||2$,$R_2)$ that $\mathcal{A}$ expects to receive. (Note that the value $R_2$ is computed using $R$ from the ECDSA signature and $k_1$ as sent by $\mathcal{A}$.)

\item[ii.] The second message $(sid,m_2)$ is processed by parsing the message $m_2$ as $(\mathsf{decom\text{-}proof}$,
$sid||1)$ from $\mathcal{A}$. If $R_1\not= k_1 \cdot G$ then $\mathcal{S}$ simulates $\text{P}_2$ aborting and the experiment concludes (since the honest $\text{P}_2$ no longer participates in any executions of the protocol and so all calls to $\Pi^1_2$ are ignored). Otherwise,  $\mathcal{S}$ computes $s_2=k_{1}\cdot s$  where $s$ is the value from the signature received from experiment-ECDSA, and sets the oracle reply to $\mathcal{A}$ to be $s_2$.
\end{enumerate}
\item[3.]  Whenever $\mathcal{A}$ halts and outputs a pair $(m^*,\sigma=(r^*,s^*))$, $\mathcal{S}$ outputs halts and $(m^*,\sigma^*=(r^*,s^*/(\mathsf{H}(m^*)+r^*\cdot x_1)\bmod q))$. 
\end{enumerate}
\end{enumerate}
As we can see, if $\mathcal{A}$ outputs a valid forgery $(m^*,\sigma=(r^*,s^*))$ of our two-party signature, where $m^*$ is not queried and $s^*=k^*(\mathsf{H}(m^*)+r^*\cdot x_1)(\mathsf{H}(m^*)+r^*\cdot x)\bmod q$, $R^*=k^*\cdot G=(r_x^*,r_y^*)$, $r^*=r_x^*\bmod q$, $\mathsf{H}(\cdot)$ denotes a hash function. Therefore,  $\mathcal{S}$ can computes a valid forgery $(m^*,\sigma^*=(r^*,s^*/(\mathsf{H}(m^*)+r^*\cdot x_1)\bmod q)=(m^*,\sigma^*=(r^*,k^*(\mathsf{H}(m^*)+r^*\cdot x)\bmod q)$ of ECDSA, where $m^*$ is not queried, $Q^*=x\cdot G$ is the verification key of ECDSA, and $x$ is the signing key of ECDSA.

In Game$_{2_2}$, there exist a PPT adversary $\mathcal{A}$ that corrupts $\text{P}_2$. We construct a PPT simulator $\mathcal{S}$ to simulates the execution for $\mathcal{A}$. Formally: 

\begin{enumerate}
\item[1.] $\mathcal{S}$ takes $(1^\lambda,Q^*)$ as input and has the access to the signing oracle of the experiment ECDSA, where $Q^*$ is the public verification key in experiment ECDSA.

\item[2.] $\mathcal{S}$ runs $\mathcal{A}$ on input $1^\lambda$ and simulates oracle $\Pi^2_2$ for $\mathcal{A}$, answering as described in the following steps:
\begin{enumerate}
\item[a)] $\mathcal{S}$ replies $\bot$ to all queries from $\mathcal{A}$ before it queries $(0,0)$. 

\item[b)] After $\mathcal{A}$ sends $(0,0)$ to the oracle $\Pi^2_2$, $\mathcal{S}$ sets $Q_1 =Q^*$. Then $\mathcal{S}$ sets the oracle reply of $\Pi^2_2$ to be $(\text{proof},1,Q_1)$ and internally hands this to $\mathcal{A}$ (as if sent by $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$).
$\mathcal{S}$ receives $(0,m_1)$ which is $\text{P}_2$'s first message in the key generation subprotocol. $\mathcal{S}$ parses $m_1$ into the form $(\mathsf{prove},2,Q_2,x_2)$  that $\text{P}_2$ sends to $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$ in the hybrid model. $\mathcal{S}$ verifies that $Q_2 = x_2\cdot G$. If no, $\mathcal{S}$  simulates $\text{P}_1$ aborting.

\item[c)] Finally, $\mathcal{A}$ can compute $Q_\text{add}=$ $Q_2$ $+$ $Q_1$, $Q_\text{mul} =$ $x_2\cdot Q_1$, $Q=$ $(Q_\text{add}$, $Q_\text{mul})$ and stores $(x_2,Q)$. $\mathcal{S}$ can compute $Q_\text{add}=Q_2+Q_1,Q_\text{mul} = x_2\cdot Q_1,Q=(Q_\text{add},Q_\text{mul})$ and stores $(x_2,Q)$. The distributed key generation phase is completed.

\item[d)] Upon receiving a query of the form $(sid,m)$ where $sid$ is a new session identifier, $\mathcal{S}$ computes the oracle reply to be $(\mathsf{proof\text{-}receipt},sid||1)$ as $\mathcal{A}$ expects to receive, and hands it to $\mathcal{A}$. Next, $\mathcal{S}$ queries its signing oracle in experiment-ECDSA with $m$ and receives back a signature $(r,s)$. Using the ECDSA verification procedure, $\mathcal{S}$ computes the Elliptic curve point $R$. Then, queries received by $\mathcal{S}$ from $\mathcal{A}$ with identifier $sid$ are processed as follows:
\begin{enumerate}
\item[i.] The first message $(sid,m_1)$ is processed by first parsing the message $m_1$ as $(\mathsf{prove}$,
$sid||2$,$R_2$,$k_2)$ that $\mathcal{A}$ sends to $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$. $\mathcal{S}$ verifies that $R_2 = k_2\cdot G$ and that $R_2$ is a non-zero point on the curve; otherwise, it simulates $\text{P}_1$ aborting. $\mathcal{S}$ computes $R_1 = k^{-1}_2\cdot R$ and sets the oracle reply to be $(\mathsf{decom\text{-}proof},sid||1,R_1)$ as if coming from $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{com\text{-}zk}}$.

\item[ii.] The second message $(sid,m_2)$ is processed by parsing $m_2$ as $s_2$. $\mathcal{S}$ computes $s'=k_2\cdot s_2\cdot s$ and check whether it is a combinatorial ECDSA or not. If yes, $\mathcal{S}$ generates signature $\sigma'=(r,s')$. Otherwise, $\mathcal{S}$ simulates $\text{P}_1$ aborting. 
\end{enumerate}
\item[3.] Whenever $\mathcal{A}$ halts and outputs a pair $(m^*,\sigma=(r^*,s^*))$, $\mathcal{S}$ outputs halts and $(m^*,\sigma^*=(r^*,s^*/(\mathsf{H}(m^*)+r^*\cdot x_2)\bmod q)$.
\end{enumerate}
\end{enumerate}
As we can see, if $\mathcal{A}$ outputs a valid forgery $(m^*,\sigma=(r^*,s^*))$ of our two-party signature, where $m^*$ is not queried and $s^*=k^*(\mathsf{H}(m^*)+r^*\cdot x_2)(\mathsf{H}(m^*)+r^*\cdot x)\bmod q$, $R^*=k^*\cdot G=(r_x^*,r_y^*)$, $r^*=r_x^*\bmod q$, $\mathsf{H}(\cdot)$ denotes the hash function. Therefore,  $\mathcal{S}$ can computes a valid forgery $(m^*,\sigma^*=(r^*,s^*/(\mathsf{H}(m^*)+r^*\cdot x_2)\bmod q)=(\mathsf{H}(m^*),\sigma^*=(r^*,k^*(\mathsf{H}(m^*)+r^*\cdot x)\bmod q)$ of ECDSA, where $m^*$ is not queried and $Q^*=x\cdot G$, $x$ is the signing key of ECDSA.

We set the probability of a PPT adversary $\mathcal{A}$ outputs a valid forgery of our two-party signature in Game$_{i_b}$ is 
$\Pr[\text{Expt\text{-}DSign}^i_{\mathcal{A},\Pi^b_2}(1^\lambda) = 1]=\mathbf{Adv}_{\Pi^b_2,i,\mathcal{A}}(1^\lambda),$
where $i\in\{1,2\}$,$b\in\{1,2\}$. 

We prove the security of the protocol in the $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}$ and $\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{com-zk}}$ hybrid model for relations $\mathsf{R}_{\text{DL}}$. Note that if the commitment and zero-knowledge protocols are UC-secure~\cite{Lin11}, then this means that the output in the hybrid and real protocols is computationally indistinguishable. 

In Game$_{2_b}$, the simulator $\mathcal{S}$ interacts with $\mathcal{A}$ based on the signing oracle in experiment-ECDSA. As we can see, $\mathcal{S}$ can interact with $\mathcal{A}$ as the oracle $\Pi_2^b$. Therefore,  
$\mathcal{S}$ can simulate the view of $\mathcal{A}$ perfectly in either Game$_{1_b}$ or Game$_{2_b}$. That is, 
$\Pr[\text{Expt\text{-}DSign}^1_{\mathcal{A},\Pi^b_2}(1^\lambda) = 1]=\Pr[\text{Expt\text{-}DSign}^2_{\mathcal{A},\Pi^b_2}(1^\lambda) = 1].$

Our proof works by showing that, in the Game$_{2_b}$, for any PPT adversary $\mathcal{A}$ attacking our two-party signature in the experiment-TP-cECDSA with the probability 
$\Pr[\text{Expt\text{-}DSign}^2_{\mathcal{A},\Pi^b_2}(1^\lambda) = 1]=\mathbf{Adv}_{\Pi^b_2,2,\mathcal{A}}(1^\lambda),$
we can construct a simulator $\mathcal{S}$ who forges an ECDSA signature in $\Pi$ the experiment-ECDSA. Because ECDSA is EUF-CMA secure, there exists a negligible function $\mathsf{negl}$ such that, 
$$\Pr[\text{Expt\text{-}Sign}_{\mathcal{A},\Pi} (1^\lambda) = 1]=\mathbf{Adv}^{\text{euf-cma}}_{\Pi,\mathcal{A}}(1^\lambda) \leq \mathsf{negl}(\lambda).$$Therefore, we conclude that 
$$\mathbf{Adv}_{\Pi^b_2,1,\mathcal{A}}(1^\lambda)=\Pr[\text{Expt\text{-}DSign}^1_{\mathcal{A},\Pi^b_2}(1^\lambda) = 1]\leq \mathsf{negl}(\lambda),$$
thus $\Pi^b_2$ is secure, separately for $b = 1$ and $b = 2$. \qed
\end{proof}


\section{Efficiency and Experimental Results}
\subsection{Theoretical Analysis}
As is shown in Table~\ref{table1} and Figure~\ref{fig2}, we review ECDSA and show our combinatorial ECDSA and two-party signature. In Table~\ref{table2}, we give the theoretical analysis of communication cost and efficiency about ECDSA, combinatorial ECDSA, Lindell's two-party ECDSA~\cite{Lin17} and our two-party signature, respectively. For convenience, we omit some simple operations of modular multiplication and addition. Intuitively speaking, Lindell's two-party ECDSA~\cite{Lin17} uses Paillier homomorphic encryption to realize the multiplication of shared secret key and a random value, and bases on a special zero-knowledge proof to prove that a value encrypted in a given ciphertext is the discrete log of a given Elliptic curve point. The above two operations are the main factors affecting the communication cost and efficiency of their two-party signature. Our combinatorial ECDSA signature can be seen as a combination of two ECDSA signatures in the structure, only increases twice point multiplication and once point addition operation in the key generation and verification phase. Benefit from these minimal costs, we greatly simplify the inversion and multiplication of shared secrets in designing a two-party signature.   

\begin{figure*}[!h]
\begin{center}
\resizebox{\textwidth}{!}{ 
\begin{tabular}{ccccc}
$\text{P}_1$ & & the key generation algorithm&     & $\text{P}_2$\\
\hline
$x_1\leftarrow \mathbb{Z}_q$ & & &  & $x_2\leftarrow \mathbb{Z}_q$\\
 $Q_1=x_1\cdot G$& &$\xrightarrow{(\mathsf{prove},1,Q_1,x_1)} \mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}\xrightarrow{(\mathsf{proof},1,Q_1)}$&  &  $Q_2=x_2\cdot G$\\
  & &$\xleftarrow{(\mathsf{proof},2,Q_2)}\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}\xleftarrow{(\mathsf{prove},2,Q_2,x_2)}$ &  &\\
 & & &  & \\
$Q_\text{add}=Q_1+Q_2$& & &     & $Q_\text{add}=Q_1+Q_2$\\
$Q_\text{mul}=x_1\cdot Q_2$& & &     & $Q_\text{mul}=x_2\cdot Q_1$\\
$Q=(Q_\text{add},Q_\text{mul})$& & &     &$Q=(Q_\text{add},Q_\text{mul})$ \\
\hline
$\text{P}_1$ & &the signing algorithm &     & $\text{P}_2$\\
\hline
$k_1\leftarrow \mathbb{Z}_q$ & & &  & \\
 $R_1=k_1\cdot G$& &$\xrightarrow{(\mathsf{com\text{-}prove},sid||1,R_1,k_1)}\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{com-zk}}\xrightarrow{(\mathsf{proof\text{-}receipt},sid||1)}$&  & $k_2\leftarrow \mathbb{Z}_q$\\
 & & &  & $R_2=k_2\cdot G$\\
 & &$\xleftarrow{(proof,sid||2,R_2)}\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{zk}}\xleftarrow{(\mathsf{prove},sid||2,R_2,k_2)}$ &  & \\
$\text{P}_1$ aborts if $(\mathsf{proof},sid||2,R_2)$ & & &  & \\
not received & & &  & \\
& &$\xrightarrow{(\mathsf{decom\text{-}proof},sid||1)}\mathcal{F}^{\mathsf{R}_{\text{DL}}}_{\text{com-zk}}\xrightarrow{(\mathsf{decom\text{-}proof},sid||1,R_1)}$ &  &$\text{P}_2$ aborts if $(\mathsf{decom\text{-}proof},$\\
$R=k_1\cdot R_2=(r_x,r_y)$   & & &  &$sid||1,R_1)$ not received \\
$r=r_x\bmod q$ & & &  & $m'=H(m)$\\
& & &  & $R=k_2\cdot R_1=(r_x,r_y)$\\
$s=k_1^{-1}(m'+r\cdot x_1)\cdot s_2\bmod q$  & & &  &$r=r_x \bmod q$  \\
If $\mathsf{Vrfy}(Q,m,(r,s))\rightarrow 0$, & & $\stackrel{s_2}{\longleftarrow}$&  & $s_2=k_2^{-1}(m'+r\cdot x_2)\bmod q$\\
 $\text{P}_1$ aborts, else returns $(r,s)$   & & &  & \\
\hline
\end{tabular}}
\caption{TP-cECDSA key generation and signing protocols}
\label{fig2}
\end{center}
\end{figure*}

\begin{table*}[!h]
\begin{center}
\caption{Comparisons of ECDSA and combinatorial ECDSA}
\label{table1}
\resizebox{\textwidth}{!}{ 
\begin{tabular}{|c|c|c|}
\hline
algorithms & ECDSA & cECDSA \\
\hline
\multirow{3}{*}{key generation}&$x\leftarrow \mathbb{Z}_q,$ &$x_1,x_2\leftarrow \mathbb{Z}_q,Q_1=x_1\cdot G,Q_2=x_2\cdot G$ \\
                &  $vk=Q=x\cdot G$                            &  $Q_\text{add}=Q_1+Q_2,Q_\text{mul}=x_1\cdot x_2\cdot G$ \\
                &                                              &$vk=Q=(Q_\text{add},Q_\text{mul})$\\
\hline
\multirow{3}{*}{signing} & $k\leftarrow \mathbb{Z}_q,R=kG=(r_x,r_y),$ & $k\leftarrow \mathbb{Z}_q,R=kG=(r_x,r_y)$   \\
        & $r=r_x\bmod q,$                      & $r=r_x\bmod q,$  \\
        & $s=k^{-1}(m+r\cdot x)\bmod q$ & $s=k^{-1}(m+r\cdot x_1)(m+r\cdot x_2)\bmod q$  \\
\hline
\multirow{2}{*}{verification} & $s^{-1}\cdot m\cdot G+s^{-1}\cdot r\cdot Q=(r_x',r_y'),$ & $s^{-1}\cdot m^2\cdot G+s^{-1}\cdot r\cdot m\cdot Q_\text{add}+s^{-1}\cdot r^2\cdot Q_\text{mul}=(r_x',r_y'),$   \\
             & $r=^?r_x'$ & $r=^?r_x'$   \\
\hline
\end{tabular}}
\end{center}
\end{table*}

\begin{table*}[!h]
\begin{center}
\caption{Communication cost and efficiency comparison}
\label{table2}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
schemes & pk & sk  & key generation & signing(online) & verification\\
\hline
\multirow{2}{*}{\small{ECDSA}}  & \multirow{2}{*}{$x\cdot G$} & \multirow{2}{*}{$x$} & \multirow{2}{*}{\small{1PM}} & \multirow{2}{*}{\small{1Hash+1MM}} & \multirow{2}{*}{\small{2PM+1PA}} \\
  &  &   &  &  &  \\

\hline

 \multirow{2}{*}{~\cite{Lin17}-\small{$\text{P}_1$}}& $pk_{\text{enc}},$ &  & \small{1PM+1KeyGen+1Enc} & \small{1Dec} &  \multirow{2}{*}{---}\\
& $x_1\cdot x_2\cdot G$& $x_1,sk_{\text{dec}}$ & \small{1DL-ZK+1PDL-ZK(p)+1P-ZK(p)} & \small{1Vrfy(ECDSA)} & \\

\hline

\multirow{2}{*}{~\cite{Lin17}-\small{$\text{P}_2$}} & $pk_{\text{enc}},$& \multirow{2}{*}{$x_2$}  & \small{2PM+1PDL-ZK(v)} & \small{1Enc} & \multirow{2}{*}{---} \\
& $x_1\cdot x_2\cdot G$&  & \small{1DL-ZK+1P-ZK(v)} & \small{1SM+1HA} & \\


\hline
\multirow{2}{*}{\small{cECDSA}} & $x_1\cdot x_2\cdot G,          $ & \multirow{2}{*}{$x_1,x_2$}  & \multirow{2}{*}{\small{2PM}} & \multirow{2}{*}{\small{1Hash+3MM}} & \multirow{2}{*}{\small{3PM+2PA}} \\
 & $                    (x_1+x_2)G$ &   &  &  &  \\

\hline

\multirow{2}{*}{\small{Ours-$\text{P}_1$}} & $x_1\cdot x_2\cdot G,    $ & \multirow{2}{*}{$x_1$}  & \small{2PM+1PA} & \multirow{2}{*}{\small{1Hash+1MM}} & \multirow{2}{*}{---}\\
 & $              (x_1+x_2)G$ &   & \small{1DL-ZK}&  &  \\
\hline

\multirow{2}{*}{\small{Ours-$\text{P}_2$}} & $x_1\cdot x_2\cdot G,    $ & \multirow{2}{*}{$x_2$}  & \small{2PM+1PA} & \multirow{2}{*}{\small{1Hash+1MM}} & \multirow{2}{*}{---} \\
 & $              (x_1+x_2)G$ &   & \small{1DL-ZK} &  &  \\

\hline
\end{tabular}
\end{center}
\scriptsize{$^\ddagger$ $x,x_1$ and $x_2$ denote the signing secret key. $G$ denotes a base point. $pk_{\text{enc}}$ and $sk_{\text{dec}}$ indicate the public key and secret key of Paillier encryption. Enc and Dec denote the encryption and decryption operation of Paillier encryption. Hash denotes the hash operation of SHA-256. MM, PM, PA and SM denote modular multiplication, point multiplication, point addition and scalar multiplication operation. PDL-ZK(v/p),P-ZK(v/p) and DL-ZK denote PDL-ZK(verification/prove operation)~\cite{Lin17}, P-ZK(verification/prove operation)~\cite{Lin17} and DL-ZK(both of verification and prove operation). Vrfy(ECDSA) denotes the verification operation of ECDSA. The symbol --- denotes that each party needs not this operation.}
\end{table*}

More precisely, with regard to Lindell's two-party ECDSA~\cite{Lin17}, in the key generation phase, each party needs four times interactions, and $\text{P}_1$ computes key generation and encryption of Paillier scheme, runs discrete log proof, proves Paillier public-key validity and runs the special zero-knowledge proof PDL-ZK. $\text{P}_2$ needs to run discrete log proof and verify the public-key validity and the proof of PDL-ZK. In the online signing phase, $\text{P}_2$ needs to compute encryption and homomorphic scalar multiplication and homomorphic addition of the Paillier scheme. $\text{P}_1$ computes Paillier decryption and ECDSA verification. Since our two-party signature avoids the complicated homomorphic encryption, it also avoids expensive zero-knowledge proof, such as P-ZK and PDL-ZK. Therefore, in the key generation phase, each party needs twice interactions, twice point multiplication operation, and once point addition operation and discrete log proof (each running as prover once and as verifier once). In the online signing phase, $\text{P}_1$ and $\text{P}_2$ take advantage of a pre-stored random value and compute part of the signature, and the operation is similar to the original ECDSA signing. Therefore, both the key generation and signing operations of each party in our two-party signature are more simple and efficient. 

\begin{table*}[!h]
\begin{center}
\caption{Computation time of ECDSA, cECDSA, and TP-cECDSA on the standard NIST curves NID.X9.62.prime256v1}
\label{table3}
\begin{tabular}{|c|c|c|c|c|}
\hline
schemes  & key generation ($\mu s$) & offline signing ($\mu s$)& online signing ($\mu s$) & verification ($\mu s$)\\
\hline
ECDSA   &11.07 &  37.03   & 2.05 & 87.56  \\
\hline
cECDSA  &22.91 &   34.90  & 3.91 & 140.62 \\
\hline
Ours-$\text{P}_1$  &61.42 &  100.2 & 2.06 & --- \\
\hline
Ours-$\text{P}_2$  &65.41 &  84.29 & 1.98 & --- \\
\hline
\end{tabular}
\end{center}
\scriptsize{$^\ddagger$ The symbol --- denotes that each party needs not this operation.}
\end{table*}

\begin{figure}[!h]
\centering
\begin{minipage}[c]{0.3\textwidth}
\centering
\begin{tikzpicture}[scale=0.55]
\begin{axis}[
    %xlabel={cycle index},
    ylabel={Computation Time(ms)},
    xmin=1000, xmax=10000,
    ymin=0, ymax=640,
    xtick={1000,2000,3000,4000,5000,6000,7000,8000,9000,10000},
    ytick={0,50,100,150,200,250,300,350,400,500,640},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=green,
    mark=*,
    ]
    coordinates {(1000,11.7192)(2000,23.4693)(3000,33.3822)(4000,45.395)(5000,60.0249)(6000,64.6554)(7000,75.2004)(8000,87.867)(9000,96.2599)(10000,110.325)
    };

\addplot[
    color=purple,
    mark=square,
    ]
    coordinates {(1000,24.1508)(2000,46.9592)(3000,67.1749)(4000,87.4914)(5000,118.216)(6000,134.05)(7000,153.382)(8000,187.432)(9000,202.435)(10000,222.535)
    };

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {(1000,61.417)(2000,114.145)(3000,174.591)(4000,235.476)(5000,293.579)(6000,350.352)(7000,419.676)(8000,464.312)(9000,537.247)(10000,564.025)
    };

\addplot[
    color=blue,
    mark=o,
    ]
    coordinates {(1000,65.4149)(2000,124.303)(3000,173.87)(4000,241.43)(5000,301.195)(6000,356.751)(7000,410.107)(8000,478.233)(9000,532.437)(10000,579.799)
    };

    \legend{{\tiny KeyGen(ECDSA)},{\tiny KeyGen(cECDSA)},{\tiny KeyGen($\text{Ours-P}_1$)},{\tiny KeyGen($\text{Ours-P}_2$)}}
\end{axis}
\end{tikzpicture}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[c]{0.3\textwidth}
\centering
\begin{tikzpicture}[scale=0.55]
\begin{axis}[
    %xlabel={cycle index},
    ylabel={Computation Time(ms)},
    xmin=1000, xmax=10000,
    ymin=0, ymax=40,
    xtick={1000,2000,3000,4000,5000,6000,7000,8000,9000,10000},
    ytick={0,5,10,15,20,25,30,35,40},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=green,
    mark=*,
    ]
    coordinates {(1000,2.23473)(2000,4.44292)(3000,5.40265)(4000,7.25486)(5000,8.92364)(6000,10.8664)(7000,12.9134)(8000,14.2866)(9000,16.3085)(10000,18.2912)
    };

\addplot[
    color=purple,
    mark=square,
    ]
    coordinates {(1000,3.60221)(2000,7.55825)(3000,10.7506)(4000,14.073)(5000,17.8018)(6000,20.9045)(7000,24.9579)(8000,28.5103)(9000,32.5792)(10000,36.8824)
    };

\addplot[
    color=red,
    mark=triangle,
    ]
    coordinates {(1000,2.00221)(2000,3.66621)(3000,5.17547)(4000,7.84743)(5000,8.70956)(6000,10.5389)(7000,12.9873)(8000,14.2937)(9000,15.5696)(10000,17.9037)
    };

\addplot[
    color=blue,
    mark=o,
    ]
    coordinates {(1000,2.08564)(2000,3.63026)(3000,5.40353)(4000,7.85864)(5000,8.91858)(6000,10.8031)(7000,12.2007)(8000,14.0962)(9000,15.8981)(10000,17.7646)
    };

    \legend{{\tiny Signing(ECDSA)},{\tiny Signing(cECDSA)},{\tiny Signing($\text{Ours-P}_1$)},{\tiny Signing($\text{Ours-P}_2$)}}
\end{axis}
\end{tikzpicture}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[c]{0.3\textwidth}
\centering
\begin{tikzpicture}[scale=0.55]
\begin{axis}[
    %xlabel={cycle index},
    ylabel={Computation Time(ms)},
    xmin=1000, xmax=10000,
    ymin=50, ymax=1400,
    xtick={1000,2000,3000,4000,5000,6000,7000,8000,9000,10000},
    ytick={50,100,200,300,400,500,600,700,800,1000,1400},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    xmajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=red,
    mark=*,
    ]
    coordinates {(1000,85.128)(2000,166.668)(3000,258.013)(4000,340.581)(5000,418.212)(6000,494.489)(7000,568.977)(8000,649.185)(9000,732.133)(10000,825.62)
    };

\addplot[
    color=green,
    mark=square,
    ]
    coordinates {(1000,131.051)(2000,268.341)(3000,400.999)(4000,528.481)(5000,659.989)(6000,832.003)(7000,932.962)(8000,1047.8)(9000,1198.28)(10000,1310.99)
    };

    \legend{{\tiny Vrfy(ECDSA)},{\tiny Vrfy(cECDSA)}}
\end{axis}
\end{tikzpicture}
\end{minipage}
\centering
\caption{Efficiency comparison of (a) keyGen, (b) signing and (c) verification operation}
\label{fig3}
\end{figure}

\subsection{Experimental Analysis}
In order to evaluate the practical performance of our schemes, we implement the ECDSA, combinatorial ECDSA, and our two-party signature based on the OpenSSL library. The implementation is given in https://github.com/tbb-tobebetter/TP-cECDSA. The program is executed on an Intel Core i5 CPU 2.3 GHz and 8GB RAM running macOS High Sierra 10.13.3 system.


\begin{trivlist}
\item \textbf{Experiment Setting and Computation Time.}
Following Lindell's two-party ECDSA~\cite{Lin17}, the first three signing steps of protocol 2 can be operated in the offline phase, so we omit this part and only realize the online signing phase of each party. In online signing phase, the operation of $\text{P}_1$ and $\text{P}_2$ is similar to calculating an ECDSA signature. As depicted in Table~\ref{table3}, Figure~\ref{fig3}, we run our implementations on the standard NIST curves NID.X9.62.prime256v1. In Table~\ref{table3}, we test the average running times of all algorithms in ECDSA, cECDSA, and our two-party signature. In Figure~\ref{fig3}, we run ECDSA, cECDSA, and our two-party signature many times respectively, and show the efficiency of the key generation, online signing, and verification operation. Based on the experimental data and analysis results, the average running times of all algorithms in combinatorial ECDSA and our two-party signature are the levels of microseconds. Especially, the running times of the online signing algorithm in TP-cECDSA-$\text{P}_1$ and TP-cECDSA-$\text{P}_2$ is similar to the original ECDSA signing algorithm. As depicted in~\cite{CCLST19}, the average running times of the key generation in ~\cite{Lin17,CCLST19} is the level of seconds, and the average running times of the signing operation in ~\cite{Lin17,CCLST19} are the level of a millisecond. Therefore, our protocol can compare with the state-of-the-art two-party signature based on ECDSA~\cite{Lin17,CCLST19}. 
\end{trivlist}

\section{Conclusion}

In this work, we first construct a combination ECDSA based on ECDSA itself, which can be seen as a combination of two ECDSA in the structure and can be split into two parts easily. Benefiting from the structure, we develop a simple and fast two-party signing protocol based on the ECDSA security, which can avoid the traditional problems of constructing two-party ECDSA showed in~\cite{MR01}. Although these problems can be solved by using additional complicated MPC techniques, such as homomorphic encryption~\cite{MR01,GGN16,Lin17}, and oblivious transfer~\cite{DKLs18,DKLs19}, etc, there are some defects in security and efficiency. Our protocol ensures that each part of the signature outputted from each party can be verified and can be combined into a combination ECDSA signature easily, so heavy MPC and expensive zero-knowledge proofs are avoided. In particular, after agreeing on random points in the offline phase, the signing operation of each party is similar to the original ECDSA in the online phase. Therefore, it can reuse the implementation of existing ECDSA and upgrade existing ECDSA applications to two-party scenarios easily. 

\Acknowledgements{This work was supported by the National Natural Science Foundation of China (Grant No. 61772522).}

\bibliography{mybib.bib}

\bibliographystyle{splncs03}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Acknowledgements. 致谢
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Acknowledgements{This work was supported by National Natural Science Foundation of China (Grant Nos. 00000000 and 11111111).}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Supplements. 补充材料, 非必选
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\Supplements{Appendix A.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Reference section. 参考文献
%%% citation in the content using "some words~\cite{1,2}".
%%% ~ is needed to make the reference number is on the same line with the word before it.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{thebibliography}{99}

% \bibitem{1} Author A, Author B, Author C. Reference title. Journal, Year, Vol: Number or pages

% \bibitem{2} Author A, Author B, Author C, et al. Reference title. In: Proceedings of Conference, Place, Year. Number or pages

% \end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Appendix sections. 附录章节, 非必选
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{appendix}
%\section{Name}

%\end{appendix}

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Some latex examples for this template
%%% 本模板使用的latex排版示例
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% sections. 章节
\section{Section title}
\subsection{Subsection title}
\subsubsection{Subsubsection title}


%%% list. 普通列表
\begin{itemize}
\item Aaa aaa.
\item Bbb bbb.
\item Ccc ccc.
\end{itemize}

%%% list-with-other-label. 自编号列表
\begin{itemize}
\itemindent 2.8em
\item[(1)] Aaa aaa.
\item[(2)] Bbb bbb.
\item[(3)] Ccc ccc.
\end{itemize}

%%% Theorem-like section. 定义、定理、引理、推论
%%% [name] can be ommited. [name]可以省略
\assumption[name]{Content.}
\corollary[name]{Content.}
\definition[name]{Content.}
\example[name]{Content.}
\lemma[name]{Content.}
\problem[name]{Content.}
\proposition[name]{Content.}
\remark[name]{Content.}
\theorem[name]{Content.}

%%% If other type of Theorem-like section, 若使用定理样式的其他前缀
%%% please use \newtheorem command before \begin{document}. 在 "作者附加的定义" 处加入\newtheorem命令
%%% For example, "Definition" section is commanded by: 例如 "Definition" 是由以下命令定义的
\newtheorem{definition}{Definition}


%%% 1-figure. 单图
%%% Please use Figure~\ref{fig1} in the text (``~'' is not omitted)
%%% 请在文中使用Figure~\ref{fig1}, 不要省略``~'', 它能够使Figure和图号不断行
%%% 双栏排版的通栏图片, 使用\begin{figure*}...\end{figure*}环境, 其他不变
%%% 双栏排版的单栏图片, 使用\begin{figure}[H]...\end{figure}环境, 其他不变
\begin{figure}[!t]
\centering
\includegraphics{fig1.eps}
\caption{Caption 1.}
\label{fig1}
\end{figure}

%%% 2-figures-in-1-row. 并排图
%%% Please use Figure~\ref{fig1} in the text (``~'' is not omitted)
%%% 请在文中使用Figure~\ref{fig1}, 不要省略``~'', 它能够使Figure和图号不断行
\begin{figure}[!t]
\centering
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{fig1.eps}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{fig2.eps}
\end{minipage}\\[3mm]
\begin{minipage}[t]{0.48\textwidth}
\centering
\caption{Caption 1.}
\label{fig1}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[t]{0.48\textwidth}
\centering
\caption{Caption 2.}
\label{fig2}
\end{minipage}
\end{figure}

%%% 2-subfigures-in-1-row. 并排子图
%%% Please use Figure~\ref{fig1} in the text (``~'' is not omitted)
%%% 请在文中使用Figure~\ref{fig1}, 不要省略``~'', 它能够使Figure和图号不断行
\begin{figure}[!t]
\centering
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{subfig1.eps}
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}[c]{0.48\textwidth}
\centering
\includegraphics{subfig2.eps}
\end{minipage}
\caption{Caption 1. (a) Subfig1 caption; (b) subfig2 caption.}
\label{fig1}
\end{figure}

%%% algorithm. 算法
%%% Please use Algorithm~\ref{alg1} in the text (``~'' is not omitted)
%%% 请在文中使用Algorithm~\ref{alg1}, 不要省略``~'', 它能够使Algorithm和算法编号不断行
%%% 双栏排版的通栏算法, 使用\begin{algorithm*}...\end{algorithm*}环境, 其他不变
%%% 双栏排版的单栏算法, 使用\begin{algorithm}[H]...\end{algorithm}环境, 其他不变
\begin{algorithm}
%\floatname{algorithm}{Algorithm}%更改算法前缀名称
%\renewcommand{\algorithmicrequire}{\textbf{Input:}}%更改输入名称
%\renewcommand{\algorithmicensure}{\textbf{Output:}}%更改输出名称
\footnotesize
\caption{Algorithm caption}
\label{alg1}
\begin{algorithmic}[1]
    \REQUIRE $n \geq 0 \vee x \neq 0$;
    \ENSURE $y = x^n$;
    \STATE $y \Leftarrow 1$;
    \IF{$n < 0$}
        \STATE $X \Leftarrow 1 / x$;
        \STATE $N \Leftarrow -n$;
    \ELSE
        \STATE $X \Leftarrow x$;
        \STATE $N \Leftarrow n$;
    \ENDIF
    \WHILE{$N \neq 0$}
        \IF{$N$ is even}
            \STATE $X \Leftarrow X \times X$;
            \STATE $N \Leftarrow N / 2$;
        \ELSE[$N$ is odd]
            \STATE $y \Leftarrow y \times X$;
            \STATE $N \Leftarrow N - 1$;
        \ENDIF
    \ENDWHILE
\end{algorithmic}
\end{algorithm}

%%% simple-table. 简单表格
%%% Please use Table~\ref{tab1} in the text (``~'' is not omitted)
%%% 请在文中使用Table~\ref{tab1}, 不要省略``~'', 它能够使Table和表号不断行
%%% 双栏排版的通栏表格, 使用\begin{table*}...\end{table*}环境, 其他不变
%%% 双栏排版的单栏表格, 使用\begin{table}[H]...\end{table}环境, 其他不变
\begin{table}[!t]
\footnotesize
\caption{Tabel caption}
\label{tab1}
\tabcolsep 49pt %space between two columns. 用于调整列间距
\begin{tabular*}{\textwidth}{cccc}
\toprule
  Title a & Title b & Title c & Title d \\\hline
  Aaa & Bbb & Ccc & Ddd\\
  Aaa & Bbb & Ccc & Ddd\\
  Aaa & Bbb & Ccc & Ddd\\
\bottomrule
\end{tabular*}
\end{table}

%%% linefeed-table. 换行表格
%%% Please use Table~\ref{tab1} in the text (``~'' is not omitted)
%%% 请在文中使用Table~\ref{tab1}, 不要省略``~'', 它能够使Table和表号不断行
\begin{table}[!t]
\footnotesize
\caption{Tabel caption}
\label{tab1}
\def\tabblank{\hspace*{10mm}} %blank leaving of both side of the table. 左右两边的留白
\begin{tabularx}{\textwidth} %using p{?mm} to define the width of a column. 用p{?mm}控制列宽
{@{\tabblank}@{\extracolsep{\fill}}cccp{100mm}@{\tabblank}}
\toprule
  Title a & Title b & Title c & Title d \\\hline
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.

  Ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd ddd.\\
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.\\
  Aaa & Bbb & Ccc & Ddd ddd ddd ddd.\\
\bottomrule
\end{tabularx}
\end{table}

%%% 1-line-equation. 单行公式
%%% Please use (\ref{eq1}) in the text. Eq.~(\ref{eq1}) is used when the equation number is the beginning of the sentence (``~'' is not omitted)
%%% 请在文中使用(\ref{eq1}), 如果是句子开头, 使用Eq.~(\ref{eq1}), 不要省略``~'', 它能够使Eq.和公式号不断行
\begin{equation}
A(d,f)=d^{l}a^{d}(f),
\label{eq1}
\end{equation}

%%% 1-line-equation-without-count-number. 不编号单行公式
\begin{equation}
\nonumber
A(d,f)=d^{l}a^{d}(f),
\end{equation}

%%% equation-array. 公式组
\begin{eqnarray}
\nonumber
&X=[x_{11},x_{12},\ldots,x_{ij},\ldots ,x_{n-1,n}]^{\rm T},\\
\nonumber
&\varepsilon=[e_{11},e_{12},\ldots ,e_{ij},\ldots ,e_{n-1,n}],\\
\nonumber
&T=[t_{11},t_{12},\ldots ,t_{ij},\ldots ,t_{n-1,n}].
\end{eqnarray}

%%% conditional-equation. 条件公式
%%% Please use (\ref{eq1}) in the text. Eq.~(\ref{eq1}) is used when the equation number is the beginning of the sentence (``~'' is not omitted)
%%% 请在文中使用(\ref{eq1}), 如果是句子开头, 使用Eq.~(\ref{eq1}), 不要省略``~'', 它能够使Eq.和公式号不断行
\begin{eqnarray}
\sum_{j=1}^{n}x_{ij}-\sum_{k=1}^{n}x_{ki}=
\left\{
\begin{aligned}
1,&\quad i=1,\\
0,&\quad i=2,\ldots ,n-1,\\
-1,&\quad i=n.
\end{aligned}
\right.
\label{eq1}
\end{eqnarray}

%%% Other. 其他格式
\proof %proof. 证明
\footnote{Comments.} %footnote. 脚注
\raisebox{-1pt}[0mm][0mm]{xxxx} %put xxxx upper or lower. 控制xxxx的垂直位置
